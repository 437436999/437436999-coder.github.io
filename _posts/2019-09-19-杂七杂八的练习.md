---
layout: post
title: 杂七杂八的练习
subtitle:   "课余自己写的编程练习整理"
date: 2019-10-07
author: Max.C
header-img: 'assets/img/pro2.jpg'
catalog: true
tags: C++ 数据结构
---

# 引言

这篇博文作为大二数据结构与算法课程自己觉得有意思的算法题的整理记录，不定时更新。

## 一、用List类实现一元多项式的表示与相加

### 1、链表的实现

结构体`Node`作为链表结点，包含指针`next`与两个整型元素：`value`系数和`index`指数。

`List`类包含头指针，头指针指向头结点，头结点默认元素为0。（加上头结点真的可以简化很多操作，insert、delete等操作不需将首尾单独实现）各个结点根据指数由低到高排列。

`List`类的成员函数包括构造函数、析构函数、插入元素、删除元素、查找元素、两个链表的相加。

```cpp
struct Node{
    Node* next;
    int value,index;
    Node(int val=0,int ind=0):value(val),index(ind),next(NULL){}
};

class List{
 public:
    Node* head;
    List() {
        head = new Node();
        head->next=NULL;
    }
    ~List(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
    }
 	void clear(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
		head = new Node();
     	head->next=NULL;
    }
    void Insert(Node* n);
    void DeleteElement(int k);
    Node* SearchkthNode(int k);
    void MergeList(List &List1, List &List2);
};
```
### 2、具体函数实现

（1）链表元素插入：

比较新加入结点`n`的指数，确定该结点插入的位置，进行插入。

```cpp
void List::Insert(Node* n){
	if(n->value==0)return;
	Node *temp=head; 
	while(temp->next != NULL){ 
		if(temp->next->index >= n->index) break;
		temp=temp->next;
	}
	if(temp->next==NULL || temp->next->index > n->index) {
		Node *p= temp->next;
		temp->next=n;
		n->next=p;
	}
	else {
		temp->next->value += n->value;
		delete n;
	}
	return;
}
```

（2）链表元素删除：

找到第k个结点，将其删除。（第一个元素定义为结点1，以此类推）

```cpp
void List::DeleteElement(int k){
	if(k<=0)return;
	Node *temp=head;
	for(int i=0;i<k-1 && temp != NULL;i++){
		temp=temp->next;
	} 
	if(temp == NULL || temp->next==NULL)return;
	Node *p=temp->next;
	temp->next=p->next;
	delete p;
	return;
}
```

（3）链表元素查找：

查找第k个结点，返回该结点的指针，若该结点不存在，返回`NULL`。

```cpp
Node* List::SearchkthNode(int k){
	if(k<=0)return NULL;
	Node *temp=head;
	for(int i=0;i<k && temp != NULL;i++){
		temp=temp->next;
	}
	return temp;
}
```

（4）两个链表进行相加：

两个链表`list1`、`list2`作为参数传入，进行成员函数操作的链表作为相加的结果。

首先，如果该链表不为空，则先将链表清空，以便插入操作。将`p1``p2`分别指向两个源链表的第一个元素（注意不是头结点），比较两个结点的指数大小，将较小的结点插入新链表尾部；若两个结点指数相等，则将两个结点的系数相加后进行插入。每进行一次插入操作，`p1``p2`向后移一位，直到指向`NULL`。

进行结点操作时注意我们的链表是有头结点的，不需要对头结点进行操作。

```cpp
void List::MergeList(List &list1, List &list2){
	if(head != list1.head && head != list2.head){
		this->clear();
	}
	Node *newhead,*p1=list1.head->next,*p2=list2.head->next;
	newhead = new Node();
	Node *t=newhead;
	while(p1 != NULL && p2 != NULL){
		if(p1->index>p2->index){
 			Node *newone=new Node(p2->value,p2->index);
 			t->next=newone;
 			t=t->next;
 			p2=p2->next;
 		}
 		else if(p1->index<p2->index){
 			Node *newone=new Node(p1->value,p1->index);
 			t->next=newone;
 			t=t->next;
 			p1=p1->next;
 		}
 		else {
 			if(p1->value+p2->value!=0){
				Node *newone=new Node(p1->value+p2->value,p1->index);
	 			t->next=newone;
	 			t=t->next;
 			}
 			p1=p1->next;
 			p2=p2->next;
 		}
	}
	while(p2!=NULL){
		Node *newone=new Node(p2->value,p2->index);
		t->next=newone;
		t=t->next;
		p2=p2->next;
	}
	while(p1!=NULL){
		Node *newone=new Node(p1->value,p1->index);
		t->next=newone;
		t=t->next;
		p1=p1->next;
	}
	head=newhead;
	return;
}
```


### 3、main测试函数

main函数利用`srand((int)time(NULL)); `与`rand()%int`生成随机数进行测试，注意包含头文件`#include<windows.h>`、`#include<time.h>`。

```cpp
int main(){
	List list1,list2;
	Node *n1,*n2;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,rand()%20);
		list1.Insert(n1);
	}
	cout<<"list1=";
	Node *t=list1.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,i);
		list2.Insert(n1);
	}
	cout<<"list2=";
	t=list2.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	List n;
	n.MergeList(list1,list2);
	t=n.head->next;
	cout<<"n=";
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
} 
```

——2019-09-06



***

## 二、链表排序

给定一个链表和一个值X，操作使得节点值小于X的节点都在大于等于X的节点的前面，并保持每个分区节点的**相对顺序**不变。

* 输入样例
3<br>
6->5->4->3->2->1->5->0

* 输出样例
2->1->0->6->5->4->3->5

### 1、链表结构

```cpp
struct linkNode {
     int val;
     linkNode *next;
     linkNode(){
			val=0;
			next=NULL;
		}
     linkNode(int x) : val(x), next(NULL) {}
     ~linkNode(){}
 };

linkNode* partList(linkNode *head, int x);
```

### 2、排序函数的实现

`linkNode* partList(linkNode *head, int x)`函数用于创造一个完成排序的链表，返回其头指针。

排序中最重要的部分是保持其**相对顺序**不变，实际上可以简单理解成将链表分割成两个子链表，每个子链表中元素的相对顺序与源链表相同，只要在最后将两个子链表连接，就可以得到排序后的链表。

源链表：6->5->4->3->2->1->5->0	（x=3）<br>
子链表一：2->1->0<br>
子链表二：6->5->4->3->5<br>
重新连接：2->1->0->6->5->4->3->5<br>

```cpp
linkNode* partList(linkNode *head, int x){
	linkNode *p=head;
	linkNode *p1=new linkNode(0); //子链表一，为其创建头结点
	linkNode *p2=new linkNode(0);//子链表二，为其创建头结点
	linkNode *h1=p1,*h2=p2; //需要记录子链表的头结点，且每次都在尾结点插入新元素
	while(p!=NULL){ //遍历整个链表
		if(p->val < x){
			p1->next=new linkNode(p->val); //若结点数值比x小，给子链表一插入元素	
			p1=p1->next;
		}
		else {
			p2->next=new linkNode(p->val);//若结点数值大于等于x，给子链表二插入元素
			p2=p2->next;
		}
		p=p->next;
	}
	p1->next=h2->next;
	return h1->next; //注意子链表一、子链表二都有头结点，返回时需要跳过                                 
}
```

### 3、main测试函数

```cpp
int main(){
	linkNode *head=NULL;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		linkNode *n1=new linkNode(rand()%20);
		n1->next=head;
		head=n1;
	}
	linkNode *head1=partList(head,10);
	while(head!=NULL){
		cout<<head->val<<endl;
		head=head->next;
	}
	cout<<endl;
	while(head1!=NULL){
		cout<<head1->val<<endl;
		head1=head1->next;
	}
} 
```

——2019-09-12



***
## 三、输入输出受限的双向队列

### 1、题目信息

>若以1234作为双端队列的输入序列，分别求出满足下列条件的输出序列：<br>
（1）能由输入受限的双端队列得到，但是不能由输出受限的双端队列得到的输出序列；<br>
（2）能由输出受限的双端队列得到，但是不能由输入受限的双端队列得到的输出序列；<br>
（3）既不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列。<br>

### 2、基本思路

由于不想手动枚举，故想到了写一个程序遍历显示所有的情况，再比较各个情况的不同部分。基本思路是先构造一个输入输出不受限的双端链表，将1、2、3、4按顺序输入，将每一次输出依次计入一个4元素的数组中，当数组满了之后就把数组打印出来，就能得到当前情况所对应的全排列。当需要输入/输出受限时，将对应的代码注释掉即可。

为了得到不受限的所有遍历，可以利用函数调用得到所有的分支，每一次的函数调用都有队首输入、队尾输入、队首输出、队尾输出四个子调用；而当用于记录的数组满了，就打印出数组，逻辑流程图如下：

![](/assets/post_img/2019-09-19/1.png)

最后我们得到的函数为`void fun(int *arr,int n,deque<int> num)`，但首先我们看看main函数：

```cpp
#include<iostream>
#include <deque>

using namespace std;

int arr0[4][24];

int main(){
	deque<int> num;
	int arr[4]={0,0,0,0};
	for(int i=0;i<4;i++){
		for(int j=0;j<24;j++){
			arr0[i][j]=0;
		}
	}
	fun(arr,1,num);
	for(int i=0;i<24;i++){
			cout<<arr0[0][i]<<arr0[1][i]<<arr0[2][i]<<arr0[3][i]<<endl;
	}
}
```

我们定义了一个全局变量`int arr0[4][24]`，这是为了储存所得到的所有不同序列，由于1234的全排列有$4!=24$种，则二维数组大小为$24\times4$，若该次遍历所得到的排列与二维数组中排列不同，则存入该数组，最后再将整个数组输出。

最后是函数的实现：

```cpp
void fun(int *arr,int n,deque<int> num){
	int arr1[4],arr2[4],arr3[4],arr4[4];
	int i=0;
	
	for(;i<4;i++){
		arr1[i]=arr[i];
		arr2[i]=arr[i];
		arr3[i]=arr[i];
		arr4[i]=arr[i];
	}
	//数组创建
	
	if(arr[3] != 0){
		int diff=1;
		for(int i=0;i<24;i++){
			if(arr0[0][i]==arr[0] && arr0[1][i]==arr[1]  && arr0[2][i]==arr[2]  && arr0[3][i]==arr[3] ){
			diff=0;
			break;
			}
		}
		int i=0;
		for(;i<24;i++){
			if(arr0[0][i]==0)break;
		}
		if(diff){
			arr0[0][i]=arr[0];
			arr0[1][i]=arr[1];
			arr0[2][i]=arr[2];
			arr0[3][i]=arr[3];
		}
		return;
	}
	//数组已满时，判断是否与已得排列重复，若不重复，写入二维数组中

	if(n<5){
		num.push_front(n);
		fun(arr1,n+1,num); 
		num.pop_front();
	}
	//队首输入
	 
	if(n<5){	
		num.push_back(n);
		fun(arr2,n+1,num); 
		num.pop_back();
	}
	//队尾输入

	if(!num.empty()){
		int i=0;
		for(;i<4;i++){
			if(arr3[i]==0)break;
		}
		arr3[i]=num.front();
		num.pop_front();
		fun(arr3,n,num); 
		num.push_front(arr3[i]);
	}
	//队首输出

	if(!num.empty()){
		int i=0;
		for(;i<4;i++){
			if(arr4[i]==0)break;
		}
		arr4[i]=num.back();
		num.pop_back();
		fun(arr4,n,num); 
		num.push_back(arr4[i]);
	}
	//队尾输出
	
	return;
}
```

第一步首先创建了四个新数组，这是因为函数调用数组是以指针的形式，并没有创建新的数组，所以我们需要手动创建；同时在对队列进行输入输出时，进行每一次输入输出、调用子函数后应将队列复原至原来的情况，以保证**对每一个函数的调用都是只针对一种情况**。

### 3、运行结果

执行输入输出的双端队列，得到的是24个全排列：

![](/assets/post_img/2019-09-19/2.png)

将其中一个输入注释掉，即输入受限，得到的结果少了4231、4213：

![](/assets/post_img/2019-09-19/3.png)

将其中一个输出注释掉，即输出受限，得到的结果少了4132、4231：

![](/assets/post_img/2019-09-19/4.png)

那我们得到的答案为：

1. 能由输入受限的双端队列得到，但是不能由输出受限的双端队列得到的输出序列:<br>
4132

2. 能由输出受限的双端队列得到，但是不能由输入受限的双端队列得到的输出序列:<br>
4213

3. 既不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列:<br>
4231

### 4、Todo

- [x] 将固定输出改为由用户输入n，生成n个数字生成的序列。
- [ ]  输出得到的排列数顺序不固定，将输出按照一定的顺序排列再输出。


——2019-09-19

***
## 四、子串定位：KMP算法

### 1、算法思路

定义主串串为**目标串S**，子串为**模式串P**。在朴素模式匹配算法中，每次匹配不成功之后，模式串只是向后移动1位，即存在**大量回溯**；我们可以利用**部分匹配**的结果，让模式串在不匹配时可以往后移动**尽量远**的距离，减少匹配次数。

KMP算法只针对模式串进行分析，对模式串求出数组Next[j]，在模式串第j位比较失败之后利用Next[j]得到往后移几位。

Next数组的实质是找模式串中的最长相同的前缀和后缀（前缀不包括最后一个字符，后缀不包括第一个字符），实际意义为**k=模式串第j位前的子串最长相同的前缀和后缀的长度+1**，即将子串移动至第k位再次进行比较，如图所示。

![](/assets/post_img/2019-09-19/5.png)

$$
Next[j] =\begin{cases}
0, j=1时 \\
Max \{ k | 1<k<j \ and\  p_1p_2…p_{k-1}= p_{j-k+1}…p_{j-1} \} \\
1,其它情况 
\end{cases}
$$

j | 1|2|3|4|5|6|7
-|-|-|-|-|-|-|-|-
S|a|b|a|c|a|b|c
Next[j]|0|1|1|2|1|2|3
NextVal[j]|0|1|0|2|0|1|3

根据上式，假设我们已经求出了next[j]数组，再将下标j按照C++的规则从0开始，就可以得到KMP算法的基本代码：

```cpp
int KMP(string s,string t){
	int i=0,j=0;
	int n=s.size(),m=t.size();
	while(i<n && j<m){
		if(j==-1 || s[i]==t[j]){
			i++;
			j++；
		}
		else{
			j=next[j];
		}
	}
	if(j==m)return i-j;
	else return -1;
}

```

### 2、Next数组

我们的代码依赖了数组next[j]，next数组的定义上面已经说明，但它的求法更加精妙，首先我们贴出它的代码：

```cpp
/*
这个算法得出的next[i]为最长前后缀的长度，即代表最长前缀的下一个字符的位置
*/
void getNext(string s){
    next[0]=-1;
    next[1]=0;
    int i=2;//i代表填充next数组的i位置
    int cn=0;//cn始终代表字符串i-1位置前面的字符串的最长前缀的下一个字符的位置
    while (i<s.size()){
  	  if(s[i-1]==s[cn])//如果字符串i-1位置上的字符等于字符串cn位置上的字符的话，直接在next[i]的基础上加1即可
  	 	 next[i++]=++cn;
 	  else if(cn>0)//这个条件满足，说明可以往前跳，让cn往前跳
         cn=next[cn];
  	  else
  	 	 next[i++]=0;//字符串i位置前面的字符串没有前缀
  	  }
}
```
以abacabc为例：
0. next[0]=-1
1. next[1]=0
2. i=2，cn=0，s[1]!=s[0]，且cn==0，next[2]=0
3. i=3，cn=0，s[2]==s[0]，next[3]=++cn=1
4. i=4，cn=1，s[3]!=s[1]，且cn>0，cn=next[1]=0，重复一次循环，i=4，cn=0，s[3]!=s[0]，next[4]=0
5. i=5，cn=0，s[4]==s[0]，next[4]=++cn=1
6. i=6，cn=0，s[5]==s[0]，next[5]=++cn=2

比较难理解的为`cn=next[cn]`这段代码，实际为将当前前缀长度跳回到cn这一字符的最长前缀，由于next[cn]的前后缀必相同，只需继续再次比较cn与i-1的字符即可，如图：

![](/assets/post_img/2019-09-19/6.png)

### 3、NextVal数组

观察s[4],当它不匹配时，按照next行回溯到s[1]也为字母a，这时再匹配a是徒劳的，因为已知a不匹配，所以就继续退回到s[1]字母a的next[1]=0。为了进行优化，就有了nextval:

若要求nextval[i]，将next[i]的值对应的位的值与i的值进行比较：
若相等，nextval[i]=nextval[ next[i] ]；
若不相等，则nextval[i]=next[i]。

代码如下：

```cpp
int get_nextval(string T){
//求模式串T的next函数修正值并存入数组nextval。
	for(int i=1;i<T.size();i++){
		if(T[next[i]] == T[i])
			nextval[i]=nextval[next[i]];
		else nextval[i]=next[i];
	}
}//get_nextval
```

——2019-10-07

***

## 五、吃豆人

有N个级别互不相同的吃豆人在一条街道的不同位置上向左或向右移动，两个吃豆人碰面时级别高的能够吃掉级别低的，吃豆人移动的速度相同，求问足够长时间过后能够存活多少个吃豆人。

- 输入格式：
第一行N代表吃豆人的数量，N在1到99999之间。
随后N行，每行2个数A,B为从左到右排列的N个吃豆人的级别和吃豆人移动的方向，A在1到99999之间，B为0表示向左，1表示向右。

- 输入
5
4 0
3 1
2 0
1 0
5 0

- 输出
2

### 1、算法思路

这道题的思路比较难，我们首先考虑两个吃豆人的情况：由于速度相同，那么←←、→→、←→的情况都不会相遇，只有在→←才可能相遇。

而在→←相遇时，等级高的会吃掉等级低的，若剩下←，这个吃豆人将不会再被吃掉（假设新的吃豆人从右边出现）；若剩下→，那接下来出现的吃豆人将有可能再次构成→←进行操作。

根据这个思路，我们可以用栈结构完成这道题，将吃豆人从左到右依次压栈，当出现→←的情况时，将需要入栈的吃豆人与栈顶的吃豆人比较，当等级低时弹出，直到栈顶的吃豆人比当前吃豆人等级高，则比较下一吃豆人（或者栈空或出现←的吃豆人，则将当前吃豆人入栈）；直到所有吃豆人都入栈之后，统计当前栈内吃豆人的个数，则是最终结果。

![](/assets/post_img/2019-09-19/7.png)

### 2、代码实现

```cpp
#include <iostream>
#include <stack>
using namespace std;

struct pa{
	int dec;
	int lev;
}; //吃豆人结构体

int main()
{
    int n;
    cin >> n;
    stack<pa> sta; 
    pa a;
    cin>>a.lev>>a.dec;
    sta.push(a); //将第一个吃豆人入栈，防止下面的判断出现栈空
    for(int i=1;i<n;i++){ //从第二个吃豆人开始
    	pa p;
    	cin>>p.lev>>p.dec;
    	if(p.dec==0 && sta.top().dec==1){ //→←的情况
    		while(!sta.empty() && sta.top().dec==1 && sta.top().lev<p.lev ){
    			sta.pop();
    		}//循环直到→←的情况结束
    		if(sta.empty() || sta.top().dec==0)
    			sta.push(p); //若结束后当前的吃豆人没被栈顶的吃掉，入栈
    	}
    	else sta.push(p); //其他情况，直接压栈即可
    }
    int num=0;
    while(!sta.empty()){
    	sta.pop();
    	num++;
    }
    cout << num;
}
```

——2019-10-07

***

## 六、括号匹配

给定一个字符串，确认该字符串中的括号是否合法，如果合法输出True，不合法输出False。
判定规则，只有形如()，[]，{}这样的格式才算合法，可以嵌套括号。

- 例：
({}[])(){}
True

({}[])(
False

没什么难度，直接栈实现，若右括号无法匹配栈中的左括号/最后栈不空，则输出False。

代码如下：

```cpp
#include<iostream>
#include<string>

using namespace std;

int main(){
	string x;
	cin>>x;
	int arr[x.size()]; //数组做栈
	int n=0; //n为元素个数，n-1指向栈顶
	for(int i=0;i<x.size();i++){
		switch(x[i]){
			case '(':{
				arr[n]=0;
				n++;
				break;
			}
			case '[':{
				arr[n]=1;
				n++;
				break;
			}
			case '{':{
				arr[n]=2;
				n++;
				break;
			}
			case ')':{
				if(arr[n-1]==0){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
			case ']':{
				if(arr[n-1]==1){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
			case '}':{
				if(arr[n-1]==2){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
		}
	}
	if(n==0)cout<<"True";
	else cout<<"False";
}
```

这道题写出来主要是为了下一道题服务。

——2019-10-09

***

## 七、最长括号子串匹配

给定一个只包含小括号的字符串，求出其中最长的有效的括号的子串的长度。

- 输入
)()()(

- 输出
4

- 输入
(()

- 输出
2

### 1、算法思路

这种有效括号的题目很容易想到使用栈stack来处理，但是这题的难点是需要找到一个明晰的思路，不然很容易逻辑混乱。解决思路为使用一个变量start来记录最初有效字串的起始下标，这里比较值得注意的是**栈中保存的不是括号字符而是括号的位置的值**，这样做的目的是为了后面计算长度：

思路如下：

1. 需有一个变量start记录有效括号子串的起始下标，max_len表示最长有效括号子串长度，初始值均为0

2. 遍历给字符串中的所有字符
1.需有一个变量start记录有效括号子串的起始下标，max_len表示最长有效括号子串长度，初始值均为0

```
2.遍历给字符串中的所有字符
    2.1若当前字符s[index]为左括号'('，将当前字符下标index入栈（下标稍后有其他用处），处理下一字符
    2.2若当前字符s[index]为右括号')'，判断当前栈是否为空
 
        2.2.1若栈为空，则start = index + 1，处理下一字符（当前字符右括号下标不入栈）
        2.2.2若栈不为空，则出栈（由于仅左括号入栈，则出栈元素对应的字符一定为左括号，可与当前字符右括号配对），判断栈是否为空
 
            2.2.2.1若栈为空，则max_len= max(max_len, index-start+1)
            2.2.2.2若栈不为空，则max_len= max(max_len, index-栈顶元素值)
```
### 2、代码实现

``` cpp
#include<iostream>
#include<string>
#include <stack>
using namespace std;

int Max(int a,int b){
	return a>b?a:b;
}

int main(){
    string str;
    cin>>str;
    int count=str.size(),max=0,start=0;
    stack<int> num;
    for(int i=0;i<count;i++){
        if(str[i]=='(')
            num.push(i);
        else {
            if(num.empty()){
                start=i+1;
            }
            else {
                num.pop();
                if(num.empty()){
                	max=Max(max,i-start+1);
                }
                else max=Max(max,num.top()-start);
            }
        }
    }
    cout<<max;
}
```
——2019-10-12

***

## 八、快速转置算法

### 1、稀疏矩阵的三元组存储

矩阵本身的数据：行、列、元素个数

矩阵元素的数据：行序号、列序号、元素值

```cpp
struct Triple{ 
  int I,j;
  elementtype e;
};	//矩阵元素

struct TSMatrix{
	Triple data[Max+1];
  int mu,nu,tu;
}; //矩阵
```

而由于稀疏矩阵的数据排列是行对齐的（根据行的顺序排列），所以如果进行转置，需要重新对数据进行排列，快速转置则是在尽可能少次数地遍历矩阵的情况下完成转置。

### 2、算法思路

首先我们给出一个$5\times5$的稀疏矩阵：

数组data |5/行|5/列|6/元素个数
-|-|-|-
0|1 |1| 3
1|1| 5| 7
2 |2| 3 |-1
3 |3 |1 |-1
4 |3| 2 |-2
5 |5 |4 |2

经过转置后，它的排列需要是这样：

数组data |5/行|5/列|6/元素个数
-|-|-|-
0|1| 1| 3
1| 1 |3| -1
2 |2 |3 |-2
3 |3 |2 |-1
4 |4 |5 |2
5 |5| 1 |7

为了预先确定矩阵M中的**每一列的第一个非零元素在数组中的位置**，需要先求得矩阵M中的**每一列中非零元素的个数**。为此，需要设置两个一维数组num[1..n]和cpot[1..n]，其中n为**矩阵列数**。

- num[]：储存每一列非零元素的个数

- cpot[]：储存每一列的**第一个**非零元素在数组中的位置

通过这两个数组，我们可以在仅遍历数组两次的情况下完成矩阵的转置：

1. 在第一次遍历时，通过对列的遍历，我们可以得到num[]。
2. cpot[1]=0
   cpot[col]=cpot[col-1]+num[col-1]
3. 第二次遍历即可根据cpot开始元素的转置：每读取一个元素，若列为i，则将行列调换，放入新的data[cpot[data[i].j]]]之中，并将cpot[i]+1。
4. 完成第二次遍历，完成算法。

### 3、代码实现

```cpp
TSMatrix trans(TSMatrix mat){
	TSMatrix nmat;
	nmat.mu=mat.nu;
	nmat.nu=mat.mu;
	nmat.tu=mat.tu;
	int num[10]={0};
	int cpot[mat.nu];
	for(int i=0;i<mat.tu;i++){
		num[mat.data[i].j]++;
	}
	cpot[0]=0;
	for(int i=1;i<mat.nu;i++){
		cpot[i]=cpot[i-1]+num[i-1];
	}
	for(int i=0;i<mat.tu;i++){
		nmat.data[cpot[mat.data[i].j]].I=mat.data[i].j;
		nmat.data[cpot[mat.data[i].j]].j=mat.data[i].I;
		nmat.data[cpot[mat.data[i].j]].e=mat.data[i].e;
		cpot[mat.data[i].j]++;
	}
	return nmat;
}
```
——2019-10-12

***

## 九、数位的组合与删除



