---
layout: post
title: 杂七杂八的练习
subtitle:   "课余自己写的编程练习整理"
date: 2019-12-11
author: Max.C
header-img: 'assets/img/pro2.jpg'
catalog: true
tags: C++ 数据结构
---

# 引言

这篇博文作为大二数据结构与算法课程自己觉得有意思的算法题的整理记录，不定时更新。

## 一、用List类实现一元多项式的表示与相加

### 1、链表的实现

结构体`Node`作为链表结点，包含指针`next`与两个整型元素：`value`系数和`index`指数。

`List`类包含头指针，头指针指向头结点，头结点默认元素为0。（加上头结点真的可以简化很多操作，insert、delete等操作不需将首尾单独实现）各个结点根据指数由低到高排列。

`List`类的成员函数包括构造函数、析构函数、插入元素、删除元素、查找元素、两个链表的相加。

```cpp
struct Node{
    Node* next;
    int value,index;
    Node(int val=0,int ind=0):value(val),index(ind),next(NULL){}
};

class List{
 public:
    Node* head;
    List() {
        head = new Node();
        head->next=NULL;
    }
    ~List(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
    }
 	void clear(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
		head = new Node();
     	head->next=NULL;
    }
    void Insert(Node* n);
    void DeleteElement(int k);
    Node* SearchkthNode(int k);
    void MergeList(List &List1, List &List2);
};
```
### 2、具体函数实现

（1）链表元素插入：

比较新加入结点`n`的指数，确定该结点插入的位置，进行插入。

```cpp
void List::Insert(Node* n){
	if(n->value==0)return;
	Node *temp=head; 
	while(temp->next != NULL){ 
		if(temp->next->index >= n->index) break;
		temp=temp->next;
	}
	if(temp->next==NULL || temp->next->index > n->index) {
		Node *p= temp->next;
		temp->next=n;
		n->next=p;
	}
	else {
		temp->next->value += n->value;
		delete n;
	}
	return;
}
```

（2）链表元素删除：

找到第k个结点，将其删除。（第一个元素定义为结点1，以此类推）

```cpp
void List::DeleteElement(int k){
	if(k<=0)return;
	Node *temp=head;
	for(int i=0;i<k-1 && temp != NULL;i++){
		temp=temp->next;
	} 
	if(temp == NULL || temp->next==NULL)return;
	Node *p=temp->next;
	temp->next=p->next;
	delete p;
	return;
}
```

（3）链表元素查找：

查找第k个结点，返回该结点的指针，若该结点不存在，返回`NULL`。

```cpp
Node* List::SearchkthNode(int k){
	if(k<=0)return NULL;
	Node *temp=head;
	for(int i=0;i<k && temp != NULL;i++){
		temp=temp->next;
	}
	return temp;
}
```

（4）两个链表进行相加：

两个链表`list1`、`list2`作为参数传入，进行成员函数操作的链表作为相加的结果。

首先，如果该链表不为空，则先将链表清空，以便插入操作。将`p1``p2`分别指向两个源链表的第一个元素（注意不是头结点），比较两个结点的指数大小，将较小的结点插入新链表尾部；若两个结点指数相等，则将两个结点的系数相加后进行插入。每进行一次插入操作，`p1``p2`向后移一位，直到指向`NULL`。

进行结点操作时注意我们的链表是有头结点的，不需要对头结点进行操作。

```cpp
void List::MergeList(List &list1, List &list2){
	if(head != list1.head && head != list2.head){
		this->clear();
	}
	Node *newhead,*p1=list1.head->next,*p2=list2.head->next;
	newhead = new Node();
	Node *t=newhead;
	while(p1 != NULL && p2 != NULL){
		if(p1->index>p2->index){
 			Node *newone=new Node(p2->value,p2->index);
 			t->next=newone;
 			t=t->next;
 			p2=p2->next;
 		}
 		else if(p1->index<p2->index){
 			Node *newone=new Node(p1->value,p1->index);
 			t->next=newone;
 			t=t->next;
 			p1=p1->next;
 		}
 		else {
 			if(p1->value+p2->value!=0){
				Node *newone=new Node(p1->value+p2->value,p1->index);
	 			t->next=newone;
	 			t=t->next;
 			}
 			p1=p1->next;
 			p2=p2->next;
 		}
	}
	while(p2!=NULL){
		Node *newone=new Node(p2->value,p2->index);
		t->next=newone;
		t=t->next;
		p2=p2->next;
	}
	while(p1!=NULL){
		Node *newone=new Node(p1->value,p1->index);
		t->next=newone;
		t=t->next;
		p1=p1->next;
	}
	head=newhead;
	return;
}
```


### 3、main测试函数

main函数利用`srand((int)time(NULL)); `与`rand()%int`生成随机数进行测试，注意包含头文件`#include<windows.h>`、`#include<time.h>`。

```cpp
int main(){
	List list1,list2;
	Node *n1,*n2;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,rand()%20);
		list1.Insert(n1);
	}
	cout<<"list1=";
	Node *t=list1.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,i);
		list2.Insert(n1);
	}
	cout<<"list2=";
	t=list2.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	List n;
	n.MergeList(list1,list2);
	t=n.head->next;
	cout<<"n=";
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
} 
```

——2019-09-06



***

## 二、链表排序

给定一个链表和一个值X，操作使得节点值小于X的节点都在大于等于X的节点的前面，并保持每个分区节点的**相对顺序**不变。

* 输入样例
3<br>
6->5->4->3->2->1->5->0

* 输出样例
2->1->0->6->5->4->3->5

### 1、链表结构

```cpp
struct linkNode {
     int val;
     linkNode *next;
     linkNode(){
			val=0;
			next=NULL;
		}
     linkNode(int x) : val(x), next(NULL) {}
     ~linkNode(){}
 };

linkNode* partList(linkNode *head, int x);
```

### 2、排序函数的实现

`linkNode* partList(linkNode *head, int x)`函数用于创造一个完成排序的链表，返回其头指针。

排序中最重要的部分是保持其**相对顺序**不变，实际上可以简单理解成将链表分割成两个子链表，每个子链表中元素的相对顺序与源链表相同，只要在最后将两个子链表连接，就可以得到排序后的链表。

源链表：6->5->4->3->2->1->5->0	（x=3）<br>
子链表一：2->1->0<br>
子链表二：6->5->4->3->5<br>
重新连接：2->1->0->6->5->4->3->5<br>

```cpp
linkNode* partList(linkNode *head, int x){
	linkNode *p=head;
	linkNode *p1=new linkNode(0); //子链表一，为其创建头结点
	linkNode *p2=new linkNode(0);//子链表二，为其创建头结点
	linkNode *h1=p1,*h2=p2; //需要记录子链表的头结点，且每次都在尾结点插入新元素
	while(p!=NULL){ //遍历整个链表
		if(p->val < x){
			p1->next=new linkNode(p->val); //若结点数值比x小，给子链表一插入元素	
			p1=p1->next;
		}
		else {
			p2->next=new linkNode(p->val);//若结点数值大于等于x，给子链表二插入元素
			p2=p2->next;
		}
		p=p->next;
	}
	p1->next=h2->next;
	return h1->next; //注意子链表一、子链表二都有头结点，返回时需要跳过                                 
}
```

### 3、main测试函数

```cpp
int main(){
	linkNode *head=NULL;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		linkNode *n1=new linkNode(rand()%20);
		n1->next=head;
		head=n1;
	}
	linkNode *head1=partList(head,10);
	while(head!=NULL){
		cout<<head->val<<endl;
		head=head->next;
	}
	cout<<endl;
	while(head1!=NULL){
		cout<<head1->val<<endl;
		head1=head1->next;
	}
} 
```

——2019-09-12



***
## 三、输入输出受限的双向队列

### 1、题目信息

>若以1234作为双端队列的输入序列，分别求出满足下列条件的输出序列：<br>
（1）能由输入受限的双端队列得到，但是不能由输出受限的双端队列得到的输出序列；<br>
（2）能由输出受限的双端队列得到，但是不能由输入受限的双端队列得到的输出序列；<br>
（3）既不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列。<br>

### 2、基本思路

由于不想手动枚举，故想到了写一个程序遍历显示所有的情况，再比较各个情况的不同部分。基本思路是先构造一个输入输出不受限的双端链表，将1、2、3、4按顺序输入，将每一次输出依次计入一个4元素的数组中，当数组满了之后就把数组打印出来，就能得到当前情况所对应的全排列。当需要输入/输出受限时，将对应的代码注释掉即可。

为了得到不受限的所有遍历，可以利用函数调用得到所有的分支，每一次的函数调用都有队首输入、队尾输入、队首输出、队尾输出四个子调用；而当用于记录的数组满了，就打印出数组，逻辑流程图如下：

![](/assets/post_img/2019-09-19/1.png)

最后我们得到的函数为`void fun(int *arr,int n,deque<int> num)`，但首先我们看看main函数：

```cpp
#include<iostream>
#include <deque>

using namespace std;

int arr0[4][24];

int main(){
	deque<int> num;
	int arr[4]={0,0,0,0};
	for(int i=0;i<4;i++){
		for(int j=0;j<24;j++){
			arr0[i][j]=0;
		}
	}
	fun(arr,1,num);
	for(int i=0;i<24;i++){
			cout<<arr0[0][i]<<arr0[1][i]<<arr0[2][i]<<arr0[3][i]<<endl;
	}
}
```

我们定义了一个全局变量`int arr0[4][24]`，这是为了储存所得到的所有不同序列，由于1234的全排列有$4!=24$种，则二维数组大小为$24\times4$，若该次遍历所得到的排列与二维数组中排列不同，则存入该数组，最后再将整个数组输出。

最后是函数的实现：

```cpp
void fun(int *arr,int n,deque<int> num){
	int arr1[4],arr2[4],arr3[4],arr4[4];
	int i=0;
	
	for(;i<4;i++){
		arr1[i]=arr[i];
		arr2[i]=arr[i];
		arr3[i]=arr[i];
		arr4[i]=arr[i];
	}
	//数组创建
	
	if(arr[3] != 0){
		int diff=1;
		for(int i=0;i<24;i++){
			if(arr0[0][i]==arr[0] && arr0[1][i]==arr[1]  && arr0[2][i]==arr[2]  && arr0[3][i]==arr[3] ){
			diff=0;
			break;
			}
		}
		int i=0;
		for(;i<24;i++){
			if(arr0[0][i]==0)break;
		}
		if(diff){
			arr0[0][i]=arr[0];
			arr0[1][i]=arr[1];
			arr0[2][i]=arr[2];
			arr0[3][i]=arr[3];
		}
		return;
	}
	//数组已满时，判断是否与已得排列重复，若不重复，写入二维数组中

	if(n<5){
		num.push_front(n);
		fun(arr1,n+1,num); 
		num.pop_front();
	}
	//队首输入
	 
	if(n<5){	
		num.push_back(n);
		fun(arr2,n+1,num); 
		num.pop_back();
	}
	//队尾输入

	if(!num.empty()){
		int i=0;
		for(;i<4;i++){
			if(arr3[i]==0)break;
		}
		arr3[i]=num.front();
		num.pop_front();
		fun(arr3,n,num); 
		num.push_front(arr3[i]);
	}
	//队首输出

	if(!num.empty()){
		int i=0;
		for(;i<4;i++){
			if(arr4[i]==0)break;
		}
		arr4[i]=num.back();
		num.pop_back();
		fun(arr4,n,num); 
		num.push_back(arr4[i]);
	}
	//队尾输出
	
	return;
}
```

第一步首先创建了四个新数组，这是因为函数调用数组是以指针的形式，并没有创建新的数组，所以我们需要手动创建；同时在对队列进行输入输出时，进行每一次输入输出、调用子函数后应将队列复原至原来的情况，以保证**对每一个函数的调用都是只针对一种情况**。

### 3、运行结果

执行输入输出的双端队列，得到的是24个全排列：

![](/assets/post_img/2019-09-19/2.png)

将其中一个输入注释掉，即输入受限，得到的结果少了4231、4213：

![](/assets/post_img/2019-09-19/3.png)

将其中一个输出注释掉，即输出受限，得到的结果少了4132、4231：

![](/assets/post_img/2019-09-19/4.png)

那我们得到的答案为：

1. 能由输入受限的双端队列得到，但是不能由输出受限的双端队列得到的输出序列:<br>
4132

2. 能由输出受限的双端队列得到，但是不能由输入受限的双端队列得到的输出序列:<br>
4213

3. 既不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列:<br>
4231

### 4、Todo

- [x] 将固定输出改为由用户输入n，生成n个数字生成的序列。
- [ ]  输出得到的排列数顺序不固定，将输出按照一定的顺序排列再输出。

——2019-09-19

***

## 四、吃豆人

有N个级别互不相同的吃豆人在一条街道的不同位置上向左或向右移动，两个吃豆人碰面时级别高的能够吃掉级别低的，吃豆人移动的速度相同，求问足够长时间过后能够存活多少个吃豆人。

- 输入格式：
第一行N代表吃豆人的数量，N在1到99999之间。
随后N行，每行2个数A,B为从左到右排列的N个吃豆人的级别和吃豆人移动的方向，A在1到99999之间，B为0表示向左，1表示向右。

- 输入
5
4 0
3 1
2 0
1 0
5 0

- 输出
2

### 1、算法思路

这道题的思路比较难，我们首先考虑两个吃豆人的情况：由于速度相同，那么←←、→→、←→的情况都不会相遇，只有在→←才可能相遇。

而在→←相遇时，等级高的会吃掉等级低的，若剩下←，这个吃豆人将不会再被吃掉（假设新的吃豆人从右边出现）；若剩下→，那接下来出现的吃豆人将有可能再次构成→←进行操作。

根据这个思路，我们可以用栈结构完成这道题，将吃豆人从左到右依次压栈，当出现→←的情况时，将需要入栈的吃豆人与栈顶的吃豆人比较，当等级低时弹出，直到栈顶的吃豆人比当前吃豆人等级高，则比较下一吃豆人（或者栈空或出现←的吃豆人，则将当前吃豆人入栈）；直到所有吃豆人都入栈之后，统计当前栈内吃豆人的个数，则是最终结果。

![](/assets/post_img/2019-09-19/7.png)

### 2、代码实现

```cpp
#include <iostream>
#include <stack>
using namespace std;

struct pa{
	int dec;
	int lev;
}; //吃豆人结构体

int main()
{
    int n;
    cin >> n;
    stack<pa> sta; 
    pa a;
    cin>>a.lev>>a.dec;
    sta.push(a); //将第一个吃豆人入栈，防止下面的判断出现栈空
    for(int i=1;i<n;i++){ //从第二个吃豆人开始
    	pa p;
    	cin>>p.lev>>p.dec;
    	if(p.dec==0 && sta.top().dec==1){ //→←的情况
    		while(!sta.empty() && sta.top().dec==1 && sta.top().lev<p.lev ){
    			sta.pop();
    		}//循环直到→←的情况结束
    		if(sta.empty() || sta.top().dec==0)
    			sta.push(p); //若结束后当前的吃豆人没被栈顶的吃掉，入栈
    	}
    	else sta.push(p); //其他情况，直接压栈即可
    }
    int num=0;
    while(!sta.empty()){
    	sta.pop();
    	num++;
    }
    cout << num;
}
```

——2019-10-07

***

## 五、括号匹配

给定一个字符串，确认该字符串中的括号是否合法，如果合法输出True，不合法输出False。
判定规则，只有形如()，[]，{}这样的格式才算合法，可以嵌套括号。

- 例：
({}[])(){}
True

({}[])(
False

没什么难度，直接栈实现，若右括号无法匹配栈中的左括号/最后栈不空，则输出False。

代码如下：

```cpp
#include<iostream>
#include<string>

using namespace std;

int main(){
	string x;
	cin>>x;
	int arr[x.size()]; //数组做栈
	int n=0; //n为元素个数，n-1指向栈顶
	for(int i=0;i<x.size();i++){
		switch(x[i]){
			case '(':{
				arr[n]=0;
				n++;
				break;
			}
			case '[':{
				arr[n]=1;
				n++;
				break;
			}
			case '{':{
				arr[n]=2;
				n++;
				break;
			}
			case ')':{
				if(arr[n-1]==0){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
			case ']':{
				if(arr[n-1]==1){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
			case '}':{
				if(arr[n-1]==2){
					n--;
				}
				else{
					cout<<"False";
					return 0;
				}
				break;
			}
		}
	}
	if(n==0)cout<<"True";
	else cout<<"False";
}
```

这道题写出来主要是为了下一道题服务。

——2019-10-09

***

## 六、最长括号子串匹配

给定一个只包含小括号的字符串，求出其中最长的有效的括号的子串的长度。

- 输入
)()()(

- 输出
4

- 输入
(()

- 输出
2

### 1、算法思路

这种有效括号的题目很容易想到使用栈stack来处理，但是这题的难点是需要找到一个明晰的思路，不然很容易逻辑混乱。解决思路为使用一个变量start来记录最初有效字串的起始下标，这里比较值得注意的是**栈中保存的不是括号字符而是括号的位置的值**，这样做的目的是为了后面计算长度：

思路如下：

1. 需有一个变量start记录有效括号子串的起始下标，max_len表示最长有效括号子串长度，初始值均为0

2. 遍历给字符串中的所有字符
1.需有一个变量start记录有效括号子串的起始下标，max_len表示最长有效括号子串长度，初始值均为0

```
2.遍历给字符串中的所有字符
    2.1若当前字符s[index]为左括号'('，将当前字符下标index入栈（下标稍后有其他用处），处理下一字符
    2.2若当前字符s[index]为右括号')'，判断当前栈是否为空
 
        2.2.1若栈为空，则start = index + 1，处理下一字符（当前字符右括号下标不入栈）
        2.2.2若栈不为空，则出栈（由于仅左括号入栈，则出栈元素对应的字符一定为左括号，可与当前字符右括号配对），判断栈是否为空
 
            2.2.2.1若栈为空，则max_len= max(max_len, index-start+1)
            2.2.2.2若栈不为空，则max_len= max(max_len, index-栈顶元素值)
```
### 2、代码实现

``` cpp
#include<iostream>
#include<string>
#include <stack>
using namespace std;

int Max(int a,int b){
	return a>b?a:b;
}

int main(){
    string str;
    cin>>str;
    int count=str.size(),max=0,start=0;
    stack<int> num;
    for(int i=0;i<count;i++){
        if(str[i]=='(')
            num.push(i);
        else {
            if(num.empty()){
                start=i+1;
            }
            else {
                num.pop();
                if(num.empty()){
                	max=Max(max,i-start+1);
                }
                else max=Max(max,num.top()-start);
            }
        }
    }
    cout<<max;
}
```
——2019-10-12

***

## 七、坐缆车

### 1、问题描述

M山上设置了n个只下山不上山的缆车点1,2…n。游客可以从山上的某一点上缆车，并从其下方任意点下缆车。缆车点i到缆车点j之间的费用为r（i，j），1<=i<=j<=n。试计算从山顶1到山脚n坐缆车所需的最少费用。

**输入格式：**

第一行一个正整数n，表示有n个缆车点，接下来n-1行是一个半矩阵,当前行表示当前点按顺序到其下方点的费用r(i，j)，从点1开始。

**输出格式：**

一个整数，表示最小费用

### 2、算法思路

本题就是一个简单的Dijkstra算法实现，给定n个缆车点和费用，图的结构和信息即得出，利用邻接矩阵存储，并进行Dijkstra运算得出最小费用即可。

### 3、代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int n;

int main(){
	cin>>n;
	int Mat[n][n];
	for(int i=0;i<n;i++){
		for(int j=1+i;j<n;j++){
			cin>>Mat[i][j];
		}
	}
	int visit[n],path[n];
	visit[0]=0;
	for(int i=1;i<n;i++){
		visit[i]=Mat[0][i];
	}
	for(int i=1;i<n;i++){
		int min=visit[i],min_ind=i;
		for(int j=i;j<n;j++){
			if(min>visit[j]){
				min=visit[j],min_ind=j;
			}
		}//找最小值 
		for(int k=min_ind+1;k<n;k++){
			int temp=visit[min_ind]+Mat[min_ind][k];
			visit[k]=visit[k]<temp?visit[k]:temp;
		}//最短路径 
	}
	cout<<visit[n-1];
} 
```

## 八、一笔画

### 1、问题描述

给定一个无向图，包含n 个顶点(编号1~n)，m条边，求最少用多少笔可以画出图中所有的边，一条边不会被描绘多次。

**输入格式：**

第一行2个数n，m，接下来m行，每行两个数a，b表示a，b两点之间有一条边相连。

**输出格式：**

一个数，表示多少笔。

### 2、算法思路

一笔画问题只需要判断图的各个结点的度的奇偶性即可，画的笔数为**奇数点个数/2**。

但是上面只是针对一个连通图得到的解题方法，当图中有多个连通分支时，需要根据每个连通分支判断。

### 3、代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int n,m;

int main(){
	cin>>n>>m;
	int count[n];
	for(int i=0;i<n;i++){
		count[i]=0;
	}
	for(int i=0;i<m;i++){
		int t1,t2;
		cin>>t1>>t2;
		count[t1-1]++;
		count[t2-1]++;
	}
	int k=0;
	for(int i=0;i<n;i++){
		if(count[i]%2==1){
			k++;
		}
	}//k为奇数点个数
	if(k==0)k=2;//当没有奇数点，只需一笔
	cout<<k/2;
} 
```

代码只能得出连通图的一笔画判断，多个连通分支的判断尚未实现。

## 九、食物链



## 十、赛马问题

### 1、问题描述

A与B之间将进行一场赛马比赛，C为裁判。A与B分别拥有n匹马，这2n匹马中每匹马拥有的能力值都不相同。比赛前，参赛的两人先决定自己的马的出场顺序；比赛时，A的第一匹马将对战B的第一匹马，A的第二匹马将对战B的第二匹马，以此类推。在每一轮的比赛当中，能力值较高的马将获得胜利，并记其拥有者加1分。进行过n轮比赛之后，得分较高的人将获得最终的胜利，并赢得所有的马。当然，可能存在平局的情况，此时算作裁判C胜利，并获得所有的马。

问：给定每一匹马的能力值，**裁判C**能否通过重新调整马匹参赛顺序而获得胜利？

**输入**：

第一行输入一个整数n，1 <= n <= 100。

第二行输入n个整数，代表选手A所有马匹的能力值。

第二行输入n个整数，代表选手B所有马匹的能力值。

**输出：**

如果可以平局的话，则输出“YES”，否则输出“NO”。

### 2、算法思路

裁判C胜利的条件为AB平局，那么，我们可以先将AB的马排序，让A能力值最高的一半与B能力值最低的一半比赛，反之让B能力值最高的一半与A能力值最低的一半比赛，确保A、B均有一半胜出。

![](/assets/post_img/2019-12-11/1.png)

而且，在这两组比较中，我们也要确保将A、B的马按顺序比较，例如A：1，2，3，4；B：3，4，5，6；依次比较1-3、2-4、3-5、4-6，才能确保B获得所有胜利。

【不能只比较A、B组中最好、最差的马，比如上述例子会出现判断出错】

### 3、代码实现

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main() {
	int n;
	cin>>n;
	int A[n],B[n];
	for(int i=0;i<n;i++){
		cin>>A[i];
	}
	for(int i=0;i<n;i++){
		cin>>B[i];
	}
	for(int i=0;i<n-1;i++){
		for(int j=i+1;j<n;j++){
			if(A[i]>A[j]){
				int temp=A[i];
				A[i]=A[j];
				A[j]=temp;
			}
			if(B[i]>B[j]){
				int temp=B[i];
				B[i]=B[j];
				B[j]=temp;
			}
		}
	}//对AB进行排序
	int yes=1;
	int mid1=n/2,mid2=mid1+1;//分成两组
	for(int i=0;i<mid1;i++){
		if(A[i]>B[i+mid1]){
			yes=0;
		}
		if(B[i]>A[i+mid1]){
			yes=0;
		}
	}
	if(yes)cout<<"YES";
	else cout<<"NO";
	return 0;
}

```

## 十一、接雨水问题

### 1、问题描述

输入N个非负整数，可以表示成一个若干个方块堆积的图，图中每一列的宽度均为1，高度为输入的数字，请计算在下雨时，该图能容纳多少面积的雨水。例如：输入[0,1,0,2,1,0,1,3,2,1,2,1]，如下图所示，则输出为6。

![](/assets/post_img/2019-12-11/2.png)

**输入描述：**

输入为两行，第一行为N，代表非负整数的个数，第二行为N个非负整数。

### 2、算法思路

算法从第一层开始计数，将每层积累的雨水数累加起来。

引入两个变量l、r，表示读取到的最邻近的两堵墙的位置；从左到右依次读取，当读取到新的墙时，更新l、r，并通过r-l得到两堵墙之间的雨水数，将其累加得到最终结果。

### 3、代码实现

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;


int main() {
	int n,h=0;
	cin>>n;
	int A[n];
	for(int i=0;i<n;i++){
		cin>>A[i];
		if(h<A[i])h=A[i];//得到最高高度
	}
	int x=0;
	for(int i=0;i<h;i++){
		int l=-1,r=-1;//初始化l、r
		for(int j=0;j<n;j++){
			if((A[j]>=i+1)){
        l=r;
				r=j;//更新
				if(r>=0 && l>=0){
					x+=(r-l-1);//累加
				}
			}
		}
	}
	cout<<x;
	return 0;
}
```

## 十二、单调上升序列

### 1、问题描述

给定一长度为n的数列，请在不改变原数列顺序的前提下，从中随机的取出一定数量的整数，并使这些整数构成单调上升序列。 输出这类单调上升序列的最大长度。

输入格式：

第一行，一正整数n，表示数列的长度
第二行，n个数，表示数列

输出格式：

一行，一个整数。

**输入样例 ：**

5
3 1 5 4 2

**输出样例 ：**

2

### 2、算法思路

这类题目需要在一个序列中**不连续**地找到子序列，让其满足一定的要求。在数据容量不大的情况下，可以使用**全局变量+函数调用**的方式进行遍历，具体实现方法如下面代码，在每一个函数中展开多个子函数直到达到终止条件。


### 3、**代码实现**

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int max1=0;
int n;
int num[1000];

void fun(int i,int o){//函数输入：当前数列的最后一个数i，序列长度o
	if(o>max1){
		max1=o;
	}//更新max1
	for(int k=i+1;k<n;k++){//包含函数终止条件
		if(num[k]>num[i])
			fun(k,o+1);//若找到比i大的数，进入子函数
	}
	return;
}

int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>num[i];
	}
	for(int i=0;i<n;i++){
		fun(i,1);
	}
	cout<<max1;
}
```

## 十三、兔子的公共祖先

### 1、问题描述

小红养了一些很可爱的兔子。 有一天，她突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。小红把兔子按出生顺序，把兔子们从1开始标号，并且小红的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小红会将父母标号更小的一对优先标号。

如果我们把这种关系用图画下来，前六个月大概就是这样的：

![](/assets/post_img/2019-12-11/3.png)

其中，一个箭头 A → B 表示 A 是 B 的祖先，相同的颜色表示同一个月出生的兔子。

为了更细致地了解兔子们是如何繁衍的，有一个问题：她想知道关于每两对兔子ai和bi，他们的最近公共祖先是谁。

一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，5 和 7 的最近公共祖先是 2，1 和 2 的最近公共祖先是 1，6 和 6 的最近公共祖先是 6。

输入格式：

一行包含 2 个正整数，表示a和b。

输出格式：

答案，一个正整数。

**输入样例：** 

2 3

**输出样例：** 

1

### 2、算法思路

首先观察其数学模型，我们可以看到每个月出生的兔子的对数满足斐波那契数列，从2号兔子开始算起，每一个月出生的兔子对数为：1、1、2、3、5、8……

而且，当月出生的兔子的祖先从1递增，如：6\~8号兔子是同一个月出生的，它们的祖先依次为1、2、3；9~13号兔子是同一个月出生的，它们的祖先依次为1、2、3、4、5。

以此，我们可以构建一个数组`rabbit[]`，用以存储每一只兔子的双亲，我们需要判断的即为`rabbit[a]`与`rabbit[b]`的共同祖先。

对于`rabbit[a]`与`rabbit[b]`的共同祖先，我们可以以如下方法判断：

1. 当`rabbit[a]==rabbit[b]`，找到共同祖先。
2. 当`rabbit[a]==b`或`rabbit[b]==a`，找到共同祖先。
3. 如果不满足上述两种情况，当`rabbit[a]<rabbit[b]`，则取`b=rabbit[b]`，（更新较大的rabbit），并继续比较；反之也相同。

### 3、代码实现

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(){
	int a,b;
	cin>>a>>b;
	if(a==b){
		cout<<a;
		return 0;
	}//特殊情况
	int num[100],rab[1000];
	num[0]=1;
	num[1]=1;
	int i=2;
	while(i){
		num[i]=num[i-1]+num[i-2];
		if(num[i]>a && num[i]>b)break;
		i++;
	}//构造斐波那契数列
	int x=0;
	for(int j=0;j<i;j++){
		for(int k=0;k<num[j];k++){
			rab[x]=k+1;
			x++;
		}
	}//构造rabbit数组
	int A=a-2,B=b-2;
	while(1){
		if(rab[A]==rab[B]){
			cout<<rab[A];
			break;
		}
		else if(A==rab[B]-2){
			cout<<A+2;
			break;
		}
		else if(B==rab[A]-2){
			cout<<B+2;
			break;
		}
		else{
			if(rab[A]<rab[B]){
				B=rab[B];
			}
			else A=rab[A];
		}
	}//判断
}
```

## 十四、重复的DNA序列

### 1、问题描述

所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，如：“ACGAATTCCG”。编写一个函数来查找 DNA 分子中所有出现超过一次的 **10 个字母长**的序列（子串）。

输入格式：

一行DNA序列。

输出格式：

所有重复的子串。

**输入样例 ：**

AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT

**输出样例 ：**

AAAAACCCCC
CCCCCAAAAA

### 2、算法思路

最简单的算法为从头读取10位长的字符串，并将每个子串与该子串位置后面的字符串比较，将符合结果的字符串输出。

问题的另一个难点为输出顺序，测例中的输出顺序是根据字典排序的，所以我们需要将符合结果的字符串先存储起来，最后再根据字典排序输出。这里可以用`set`进行自动的排序。

### 3、代码实现

```cpp
#include <iostream>
#include <string>
#include <set>
#include <string>
#include <algorithm>

using namespace std;

set<string> S;//容器

void com(string str,int i){
	for(int k=i+1;k<str.size()-10;k++){
		string t=str.substr(k,10);
		string s=str.substr(i,10);
		if(s==t){
			S.insert(s);//满足条件，插入
			return;
		}
	}
}

int main() {
	string str;
	cin>>str;
	for(int i=0;i<str.size()-10;i++){
		com(str,i);
	}	
	for(set<string>::iterator it=S.begin();it!=S.end();it++)
 		cout<<*it<<endl;//迭代器遍历
}
```

## 十五、索引处的解码字符串

### 1、问题描述

给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：

如果所读的字符是字母，则将该字母写在磁带上。

如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。

现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。

输入格式：

两行，第一行为编码的字符串，第二行为K

输出格式：

解码后的第K个字母。

**输入样例 ：**

leet2code3
10

**输出样例 ：**

o

**解释 ：**

解码后的字符串为 "leetleetcodeleetleetcodeleetleetcode"。
字符串中的第 10 个字母是 "o"。

### 2、算法思路

依次读取原字符串str的每一位，解码得出结果字符串code，将其输出即可。

将字符串中的连续数字转换为整型的框架如下：

```cpp
	int num=0;		
	if(str[i]<='9' && str[i] >= '0'){
		num*=10;
		num+=(str[i]-'0');
	}
```

但是，检查测例中出现了一种特殊情况：`a2445657646`，且输出的为第1个字母。如果将此字符串解码，无疑会发生越界。那么，我们只能在解码时增加一点限制条件，让其不发生越界，且满足其他测例的解码要求。（我使用的方法是限制转换得到的数字的大小，让数字大小的上界不超过某一个较大的数，这样可以保证不发生越界，且满足其他测例）

### 3、代码实现

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int main() {
	string str,code;
	cin>>str;
	int n;
	cin>>n;
	int num=0;
	for(int i=0;i<=str.size();i++){
		if(str[i]<='9' && str[i] >= '0'){
			if(num>n*100){
				break;
			}//限制大小
			num*=10;
			num+=(str[i]-'0');
		}
		else {
			if(num){
				string code0=code;
				for(int j=0;j<num-1;j++){
					code+=code0;
				}
				num=0;
			}
			code+=str[i];
		}
	} 
	cout<<code[n-1];
}
```

## 十六、拼数

### 1、问题描述

设有n个正整数，将它们联接成一排，组成一个最大的多位整数。
输入格式
第一行，一个正整数n。
第二行，n个正整数。
输出格式
一个正整数，表示最大的整数

输入样例 ：

3
13 312 343

输出样例 ：

34331213

### 2、算法思路

本质上是把输入的数组进行排序，排序后依次输出。

一开始的思路是每次都从最高位开始比较，后来细化了一下思路，发现将每个数字作为字符串进行处理时最为简单的，我自己实现的思路为：依次比较字符串的每一位（从第0位开始），将比较结果较小的调至后面。

```cpp
int s=num[i].size()>num[j].size()?num[j].size():num[i].size();
for(int k=0;k<s;k++)
{
	if(num[i][k]>num[j][k])
	{
		break;
	}
	else if(num[i][k]<num[j][k])
	{
  	string t=num[i];
  	num[i] = num[j];
  	num[j] = t;
	}
}
```

答案使用了更加简单的方法实现比较，对字符串A、B，直接比较A+B>A-B是否成立（由于是`string`类型，可以直接比较），根据比较结果排序即可。

### 3、代码实现

```cpp
#include<bits/stdc++.h> 
using namespace std;
string a[30]; //使用string更方便一些(可以直接比较大小)
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i]; //读入
    for(int i=1;i<n;i++) //排序
    {
        for(int j=i+1;j<=n;j++)
        {
            if(a[j]+a[i]>a[i]+a[j]) //string类型可以直接比较大小
            {
                swap(a[j],a[i]);  //交换a[i]与a[j],同样可以用swap(a[i],a[j]);
                /*
                    举个例子:如果是12,34，由于3412>1234，所以肯定要交换一下，直接用swap就可以了
                */
            }
        }
    } //排序结束
    for(int i=1;i<=n;i++) cout<<a[i]; //由于已经排好序了，直接输出即可
    return 0;
}
```

## 十七、按要求处理数字

### 1、问题描述

给定一个数列，对于其中重复的数字，只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序

输入格式：

第1行为一个正整数N，表示了数列长度。第2行包含N个非负整数。

输出格式：

共2行，第一行为处理后数列的长度，第二行为数字以空格隔开的处理后数列。

**输入样例 :**

3
2 1 1

**输出样例 :**

2
1 2

### 2、算法思路

把这道题写进来是为了熟悉STL的用法。

为了得到顺序、不重复的序列，第一个想法就是使用`set`容器。将输入的数字一个一个加入`set`中，然后直接利用迭代器输出即可。

### 3、代码实现

```cpp
#include<iostream>
#include<set>

using namespace std;

int main(){
	int n;
	cin >> n;
	set<int> s;
	for(int i=0;i<n;i++){
		int t;
		cin>>t;
		s.insert(t);
	}
	cout<<s.size()<<endl;
	for(set<int>::iterator it=s.begin();it != s.end();it++){
		cout<<*it<<" ";
	}
	/*
	另一种输出方式
  while(!s.empty())
  {
  	cout<<*s.begin()<<" ";           
  	s.erase(s.begin()); 
  }
	*/
}
```

## 十八、切木板

### 1、问题描述

小明想要亲自修复在他的一个小牧场周围的围栏。他测量栅栏并发现他需要N根木板，每根的长度为整数Li。于是，他神奇地买了一根足够长的木板，长度为所需的N根木板的长度的总和，他决定将这根木板切成所需的N根木板。（小明在切割木板时不会产生木屑，不需考虑切割时损耗的长度)小明切割木板时使用的是一种特殊的方式，这种方式在将一根长度为x的模板切为两根时，需要消耗x个单位的能量。小明拥有无尽的能量，但现在提倡节约能量，所以作为榜样，他决定尽可能节约能量。显然，总共需要切割N-1次，问题是，每次应该怎么切呢？请编程计算最少需要消耗的能量总和。

输入格式：

第一行: 整数N，表示所需木板的数量；

第2到N+1行: 每行为一个整数，表示一块木板的长度；

输出格式：

一个整数，表示最少需要消耗的能量总和。

**输入样例 ：**

3
8
5
8

**输出样例 ：**

34

### 2、算法思路

首先，先将木板按从小到大的顺序排列，由于木板长度可重复，我们可以使用`multiset`实现。

经过举例并进行验证，发现最快的方式为每一步都进行二分，如果当前木板恰有奇数个，则切木板的位置**偏向较大**的一边，例如：

2 4 7 8 9

2 4 7 | 8 9

2 4 | 7        8 | 9

2 | 4

为了实现二分，我们使用递归来实现，并引入一个长度为N的数组`num`，用来记录第i块木板被切了多少次，最终结果为：

$result = \sum^{n-1}_{i=0}num[i]\times length_i$

### 3、代码实现

```cpp
#include<iostream>
#include<set>

using namespace std;

void fun(int *num,int l,int r){//num为辅助数组，l、r为起止点（包括r）
	int n=r-l+1；//当前需要分的木板长度
	if(n==1)return; //长度为一，返回
	for(int i=l;i<=r;i++){
		num[i]++;//将当前的木板次数均+1
	}
	int mid;//取中点，根据奇偶区分
	if(n%2==0){
		mid = l+n/2;
	}
	else{
		mid = l+n/2+1;
	}
	fun(num,l,mid-1);//递归左边
	fun(num,mid,r);//递归右边
}

int main(){
	int n;
	cin >> n;
	multiset<int> s;
	int num[n];//辅助数组
	for(int i=0;i<n;i++){
		int t;
		cin>>t;
		s.insert(t);
		num[i]=0;//初始化
	}
	fun(num,0,n-1);//二分计算
	int max=0,i=0;
	multiset<int>::iterator it=s.begin();
	for(;it != s.end();it++){
		max+=num[i]*(*it);
        i++;
	}
	cout<<max;
}
```

## 十七、火星人

### 1、问题描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为1,2,3…。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为1,2,3,4和5，当它们按正常顺序排列时，形成了5位数12345，当你交换无名指和小指的位置时，会形成5位数12354，当你把五个手指的顺序完全颠倒时，会形成54321，在所有能够形成的120个5位数中，12345最小，它表示1；12354第二小，它表示2；54321最大，它表示120。下表展示了只有3根手指时能够形成的6个3位数和它们代表的数字：

三进制数

123 132 213 231 312 321

代表的数字

1 2 3 4 5 6

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

输入格式：

第一行一个正整数N，表示火星人手指的数目。
第二行是一个正整数M，表示要加上去的小整数。
下一行是1到N这N个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。

输出格式：

N个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。

**输入样例 :**

5
3
1 2 3 4 5

**输出样例 :**

1 2 4 5 3

### 2、算法思路

题目有点长，不过题意简单来说就是求出当前给出的全排列的第下m个全排列。

可以直接使用离散数学学过的求不重复全排列的算法实现，代码实现也不困难，需要找到两个位置j、p，j是第一个需要调换的位置，p为j后面可以与之调换的位置。调换后将j后面的数字从小到大排序即可。

### 3、代码实现

```cpp
#include<iostream>
#include<set>

using namespace std;

int main(){
	int n,m;
	cin >> n >> m;
	int num[n];
	for(int i=0;i<n;i++){
		int t;
		cin>>t;
		num[i]=t;
	}
	for(int i=0;i<m;i++){//开始计算全排列
		int j=n-2;
		for(;j>=0;j--){
			if(num[j]<num[j+1])break;
		}//找到位置j
		int p=n-1;
		for(;p>=0;p--){
			if(num[j]<num[p])break;
		}//找到位置p，将j、p交换
		int temp=num[p];
		num[p] = num[j];
		num[j] = temp;
		j++;
		k=n-1;
		while((j<k))//把后面的逆序，相当于从小到大排序 
     {
       t=b[j];  
       b[j]=b[k];
       b[k]=t;
       j++;
       k--;
     }
	}
	for(int i=0;i<n;i++){
		cout << num[i] <<" ";
	}
}
```

## 十八、最短电文

### 1、问题描述

对于一份英文电文，我们可以通过二进制前缀编码（Huffman Coding），将其变为只含“01”的二进制序列。现假设该电文只含小写英文字母（a-z），且至少包含两个不同的字符。要求我们求出该电文经过编码后的长度。

**输入样例 :**

ssuuusuluu

**输出样例 :**

14

### 2、算法思路

构造哈夫曼树实现即可，不过构造之后需要依次读取字符结点的父结点，得到编码长度再做计算。

哈夫曼树的结点结构如下：

```cpp
class TreeNode{
	public:
		int anc;//编码长度
		int al;//对应哪个字母
		int weight;
		int par;
		int lc,rc;
		TreeNode(){
			par=lc=rc=-1;
			weight=0;
			al=-1;
			anc=0;
		}
};
```



### 3、代码实现

```cpp
#include <iostream>
#include <stack>
#include <cstring>
using namespace std;

class TreeNode{
	public:
		int anc;
		int al;
		int weight;
		int par;
		int lc,rc;
		TreeNode(){
			par=lc=rc=-1;
			weight=0;
			al=-1;
			anc=0;
		}
};

int main(){
	string str;
	cin >> str;
	int alg[26] = {0};
	for(int i=0 ; i<str.size();i++){
		alg[str[i]-'a']++;
	}
	int num=0;
	for(int i=0 ; i<26;i++){
		if(alg[i] > 0)num++;
	}
	TreeNode t[2*num-1];
	int j=0;
	for(int i=0 ; i<26;i++){
		if(alg[i] > 0){
			t[j].al=i;
			t[j].weight = alg[i];
			j++;
		}
	}
	for(int i=num ; i<2*num-1;i++){
		int min1=999,min2=999,min1_ind=0,min2_ind=0;
		for(int j=0;j<i;j++){//find min1
			if(t[j].par == -1 && t[j].weight < min1){
				min1 = t[j].weight;
				min1_ind = j;
			}
		}
		for(int j=0;j<i;j++){//find min2
			if(t[j].par == -1 && j != min1_ind && t[j].weight < min2){
				min2 = t[j].weight;
				min2_ind = j;
			}
		}
		t[i].weight = min1+min2;
		t[i].lc = min1_ind;
		t[i].rc = min2_ind;
		t[min1_ind].par = t[min2_ind].par = i;
		//构造新结点
	}
	int res=0;
	for(int i=0;i<num;i++){
		int k=i;
		while(t[k].par != -1){
			k=t[k].par;
			t[i].anc++;
			//计算编码长度
		}
		res+=(t[i].anc*t[i].weight);//计算结果
	}
	cout<<res<<endl;
    return 0;
}

```

## 十九、种花

### 1、问题描述

假设你有一个长的花坛，其中一些地块种植着花，另一些没有。 然而，花不能种植在相邻的地块否则他们会争取水导致两者都死亡。 给定一个花坛（表示为包含0和1的数组，其中0表示没有种花，1表示种植着花）以及数字n。如果n个新鲜花可以种植在其中则返回真，否则返回假。

输入格式：

第一行输入数字m，表示花坛的地块数目，可以输入花坛目前的状态（用0,1）表示，第三行输入还需要种植的花的数目n。

输出格式：

为每个测试用例单独输出一行。

**输入样例 :**

5 

1 0 0 0 1 

1

**输出样例 :**

1

### 2、算法思路

用数组存储花坛，并用一个变量计数。

直接遍历一次数组，当第i个元素为0时，若其相邻元素均为0，则可以种花，将其赋值为1，并将计数变量+1。最后判断计数变量和n的大小即可输出结果。

为了处理边界情况，可以将数组长度设置为m+2，并将首尾均置为0；遍历时从i=1开始即可。

### 3、代码实现

```cpp
#include <iostream>
#include <stack>
#include <cstring>
using namespace std;


int main(){
	int n,m;
	cin>>m;
	bool flower[m+2];
	flower[0] = flower[m+1] = 0;
	for(int i=1;i<=m;i++){
		cin >> flower[i];
	}
	cin>>n;
	int res=0;
	for(int i=1;i<=m;i++){
		if(flower[i] == 0){
			if(flower[i-1] == 0 && flower[i+1] == 0){
				res++;
				flower[i] = 1;
			}
		}
	}
	cout<<(res>=n);
    return 0;
}
```
## 二十、1的块数

### 1、问题描述

输入一个NxM矩阵（0或1），找出其中'1'的块数，互相相邻（包括对角线）的1称为一个块。

输入：第一行为两个正整数N，M（1<=N<= 100,1<=M<= 100），代表该矩阵的行列； 接下来输入一个NxM矩阵（0或1）。

输出：该矩阵中'1'的块数。

**输入样例 :**

4 4
1 0 0 0
0 0 1 0
0 1 0 1
1 0 0 0

**输出样例 :**

2（左上角的1作为一块，其余的1由于相连，也作为一块）

### 2、算法思路

此题如果能够理解题目，就很好解决。将每一组相邻的1作为一块，计算矩阵中1的块数。

在主函数中遍历一遍矩阵，遇到1的时候可以将块数+1并进入递归，在递归内将当前块的所有1都置为0。遍历完整个矩阵后即可得到结果。

同样是处理边界问题，也是在矩阵外围加上一圈，并置为0，这样在讨论时可以避免讨论边界条件。或者将判断条件设置为如下：

```cpp
for (int i = -1; i <= 1; ++i) {
		for (int j = -1; j <= 1; ++j) {
			tx = x + i;
			ty = y + j;
			if (tx >= 0 
          && tx < n 
          && ty >= 0 
          && ty < m 
          && map[tx][ty] == true) 
      {
				fun(tx, ty);
			}
		}
}
```

### 3、代码实现

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;

bool M[100][100];//全局变量自动初始化为0
int x,y;

void fun(int i,int j){
	M[i][j]=0;
		if(M[i-1][j-1] == 1){
			fun(i-1,j-1);
		}
		if(M[i-1][j] == 1){
			fun(i-1,j);
		}
		if(M[i-1][j+1] == 1){
			fun(i-1,j+1);
		}
		if(M[i][j-1] == 1){
			fun(i,j-1);
		}
		if(M[i][j+1] == 1){
			fun(i,j+1);
		}
		if(M[i+1][j-1] == 1){
			fun(i+1,j-1);
		}
		if(M[i+1][j] == 1){
			fun(i+1,j);
		}
		if(M[i+1][j+1] == 1){
			fun(i+1,j+1);
		}
}

int main(){
	cin >> x >> y;
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++){//留下一个边界
			cin >> M[i][j];
		}
	}
	int res = 0;
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++){
			if(M[i][j] == 1){
				fun(i,j);//处理一个块
				res++;//块数+1
			}
		}
	}
	cout << res << endl;
    return 0;
}
```

## 二十一、找出和最接近的数

### 1、问题描述

输入一个整型数组S，以及一个目标整数target，从数组中找出三个数，使得他们的和最接近target，假设对于每一组输入，均对应唯一一个结果。

输入描述：

输入为三行，第一行为数组大小N；第二行为整型数组；第三行为目标整数target。

输出描述：

输出最接近target的三个数的和（假设输出的结果唯一）。

**输入样例 :**

4
-1 1 2 4
1

**输出样例 :**

2

### 2、算法思路

原来使用了3个for循环实现，不过效率实在过低，接下来说明一下标答的思路：

得到输入的数组后，先从小到大进行排序，取第一个数`front`、最后一个数`rear`作为三个数的首尾，然后**取`1<=i<=n-2`作为三个数的中间数**依次进行讨论。每次讨论时，比较三个数的和与target的大小，如果大于`taeget`，将`rear--`；若小于`target`，将`front++`。每次还需要比较`temp - target`的绝对值大小，取最小的值作为我们的结果。

### 3、代码实现

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int sim = 999999999;
        int result = 0;
        for (int i = 1; i < nums.size() - 1; i++)
        {
            int temp = 0;
            int front = 0;
            int rear = nums.size() - 1;
            while (i > front && i < rear)
            {
                temp = nums[front] + nums[i] + nums[rear];
                if (temp == target) return target;
                if(abs(temp - target) < sim) 
                {
                    sim = abs(temp - target);
                    result = temp;
                }
                (temp < target) ? (front++) : (rear--);
            }
        }
        return result;
    }
int main()
{
    std::vector<int> v;
    int N;
    cin >> N;
    int temp;
    for (int i = 0; i < N; ++i)
    {
        cin >> temp;
        v.push_back(temp);
    }
    int target;
    cin >> target;
    cout << threeSumClosest(v, target);
    return 0;
}
```

