---
layout: post
title: 双目匹配
date: 2019-11-22
author: Max.C
header-img: 'assets/img/pro7.jpg'
catalog: true
tags: openCV 双目立体匹配
---

# 一、双目匹配步骤


双目匹配实际操作主要分为4个步骤：相机标定—图像校正—双目立体匹配—获取深度。

### 相机标定：

张氏相机标定法利用不同角度拍摄的多张棋盘图像，计算出相应的内参：$f_x, f_y, c_x, c_y$（内参）,以及畸变系数$k_1,k_2,k_3,p_1,p_2$（径向畸变、切向畸变参数）。

然后进行外参的标定，得到两个相机的旋转矩阵和平移向量，再通过左右相机的内外参数，通过立体标定对左右两幅图像进行立体校准和对齐，最后确定两个相机的相对位置。

### 图像校正：

首先通过畸变系数进行畸变校正，径向畸变的校正公式为：

$x_c=x(1+k_1r^2+k_2r^4+k_3r^6)$

$y_c=y(1+k_1r^2+k_2r^4+k_3r^6)$

切向畸变的校正公式为：

$x_c=x+[2p_1y+p_2(r^2+2x^2)]$

$y_c=y+[2p_2x+p_1(r^2+2y^2)]$

然后进行立体校正，使得左右图像的成像原点坐标一致、两摄像头光轴平行、左右成像平面共面，这样一幅图像上任意像素点与其在另一幅图像上的对应点一定在同一行上，只需要对该行进行一维搜索即可匹配到对应点。

如下图，经过图像校正将两幅灰色图像校正为下侧共面的图像。

![]( /assets/post_img/2019-11-07/2.png)

### 双目立体匹配：

双目立体匹配是把左右图像上对应的像素点匹配起来，得到视差图。

由于经过了立体校正后，匹配点是在同一行上的，所以可以在两张图的同一行中查找匹配点，通过匹配点得到每个点的视差d（下文提及）。

### 获取深度：

 经过上面步骤的调整，我们找到了图像中对应点的参数，可以通过公式$z=\frac{b f}{d}$算出图像中各像素点所对应的深度信息，得到深度图。

公式$z=\frac{b f}{d}$的推导如下：

已知焦距为f，基线距离为b，左相机中所求像素点对于图像中心的偏移量$(xl,yl)$，右相机中对应像素点对于图像中心的偏移量$(xr,yr)$，我们需要求的是深度z，如下图：

![](/assets/post_img/2019-11-07/1.png)

通过相似三角形的知识得到式子$z=f\times\frac{x}{xl},z=f\times\frac{x-b}{xr}$

有z、x两个未知量，由第一道式子有$x=\frac{z \cdot  xl}{f}$

代入第二道式子：$z=f\times\frac{\frac{z \cdot  xl}{f}-b}{xr}=\frac{z\cdot xl-bf}{xr}$

化简得$z=\frac{bf}{xl-xr}$

我们将xl-xr定义为视差d，则$z=\frac{bf}{d}$。

***

# 二、图像校正

## 1、畸变矫正

### a、原理

通过摄像机将三维物体映射到二维图像中，是从世界坐标系到像素坐标系的映射过程。而因为透镜的成像原理，映射得到的图像会出现一定的畸变。（包括径向畸变和切向畸变）

![](/assets/post_img/2019-11-22/1.png)

对图像进行畸变矫正，即根据矫正原理和相机标定时得到的畸变参数，建立一个从**原图像坐标**到**矫正后图像坐标**的映射：$f(u,v)=(u_c,v_c)$

而由于摄影机成像时会有从**实际图像坐标系到像素坐标系**的转换$(x,y)→(u,v)$，矫正需要相对于图像坐标系，那么我们的矫正需要经过这样一个过程：

$$
h(u,v)=(x,y)\\
f(x,y)=(x_c,y_c)\\
g(x_c,y_c)=(u_c,v_c)
$$

![](/assets/post_img/2019-11-22/2.png)



从图像坐标系到像素坐标系的映射公式比较简单，如下：
$$
u=f_x\sdot x+c_x\\
v=f_y\sdot y+c_y
$$
可以直接得到$h(u,v)=(x,y)$求出矫正前的$(x,y)$；

$$
u_c=f_x\sdot x_c+c_x\\
v_c=f_y\sdot y_c+c_y
$$

同理，矫正后的映射$g(x_c,y_c)=(u_c,v_c)$也直接利用上述公式得到。

接下来需要根据畸变矫正原理得到$f(x,y)=(x_c,y_c)$矫正的映射，分别处理径向畸变和切向畸变，公式如下：

![]( /assets/post_img/2019-11-06/5.png)

**径向畸变**：我们常用r=0（光心）处的泰勒级数展开的前几项来近似描述径向畸变。矫正径向畸变前后的坐标关系为：

$x_c=x(1+k_1r^2+k_2r^4+k_3r^6)$

$y_c=y(1+k_1r^2+k_2r^4+k_3r^6)$

$r^2=x^2+y^2$

**切向畸变**：切向畸变需要两个额外的畸变参数来描述，矫正前后的坐标关系为：

$x_c=x+[2p_1y+p_2(r^2+2x^2)]$

$y_c=y+[2p_2x+p_1(r^2+2y^2)]$

合并后得到：

$x_c=x(1+k_1r^2+k_2r^4+k_3r^6)+[2p_1y+p_2(r^2+2x^2)]$

$y_c=y(1+k_1r^2+k_2r^4+k_3r^6)+[2p_2x+p_1(r^2+2y^2)]$

$r^2=x^2+y^2$

这就是我们需要的映射$f(x,y)=(x_c,y_c)$。

由于存在畸变，畸变前坐标为整数，畸变后并不一定为整数。而在像素坐标系中，坐标都是整数，因此在这个过程中往往存在插值操作。（一般使用双线性插值的方法？）

### b、openCV畸变矫正

openCV首先通过`initUndistortRectifyMap()`函数计算矫正映射。

```cpp
void initUndistortRectifyMap( 
  InputArray cameraMatrix, 
  InputArray distCoeffs,
  InputArray R, 
  InputArray newCameraMatrix,
  Size size, 
  int m1type, 
  OutputArray map1,
  OutputArray map2 
);
```

其中最后三个变量`m1type`、`map1`、`map2`指定了矫正映射的类型。

《学习openCV3》里介绍了矫正映射的几种表示方法，不过我还不太理解这几个矫正映射和具体图像的对应关系。

* 双通道浮点数表示CV_32FC2：

映射由一个双通道浮点数NxM矩阵表示，矩阵中的每一个元素包含一个坐标，对应**原图像中该像素坐标**所对应**矫正后图像像素坐标**。在`initUndistortRectifyMap()`函数中通过`map1`表示。

若$map[2][3]=(4,5)$，则矫正后图像$(4,5)$上的像素点即为原图像中$(2,3)$上的像素点。（这个理解正确么？）

* 双矩阵浮点数表示CV_32FC1：

原理同上，不过由一个矩阵变成两个矩阵，一个矩阵对应X坐标，另一个矩阵对应Y坐标。在`initUndistortRectifyMap()`函数中通过`map1`、`map2`表示。

* 定点表示CV_16SC2：

映射由一个双通道有符号整数NxM矩阵表示，在`initUndistortRectifyMap()`函数中通过`map1`表示。

前面几个参数含义如下：

1. `cameraMatrix`：内参矩阵$\begin{bmatrix}{f_x}&{0}&{c_x}\\{0}&{f_y}&{c_y}\\{0}&{0}&{1}\end{bmatrix}$
2. `distCoeffs`：畸变参数$k_1\ k_2\ p_1\ p_2\ (k_3 \dots)$，一般有4、5、8、12或14个元素。（不同数量的元素代表畸变矫正的精确度？）
3. `R`：修正变换矩阵，不太理解它的作用。
4. `newCameraMatrix`：新的内参矩阵。
5. `size`：畸变矫正后图像大小。

得到矫正映射后，我们可以利用`remap()`函数将它们应用到实际图像中，在此过程中对坐标进行**插值操作**。

```cpp
Void remap(
InputArray src,
OutputArray dst,
InputArray map1,
InputArray map2,
int interpolation,
int borderMode=BORDER_CONSTANT,
const Scalar&borderValue=Scalar()
);
```
各参数含义如下：
1. `src`：待矫正的原图像
2. `dst`：经过矫正后的图像输出
3. `map1`、`map2`：矫正映射
4. `interpolation`：插值方式
5. `borderMode`：边界插值类型
6. `borderValue`：插值数值（？）

## 2、极线校正

### a、原理




## 参考资料

- [相机标定（4） 矫正畸变 undistort()和initUndistortRectifyMap()](https://blog.csdn.net/qq_30815237/article/details/87622654)
- [OpenCV学习(5): 图像畸变校正](https://blog.csdn.net/xholes/article/details/80599802)
- [图像矫正去畸变](https://blog.csdn.net/weixin_38009585/article/details/82356022)
- [[Opencv remap()重映射函数详解及使用示例](https://www.cnblogs.com/HL-space/p/10546595.html)](https://www.cnblogs.com/HL-space/p/10546595.html)
- 

