---
layout: post
title: 杂七杂八的练习
subtitle:   "课余自己写的编程练习整理"
date: 2019-09-12
author: Max.C
header-img: 'assets/img/pro2.jpg'
catalog: true
tags: C++ 数据结构
---

# 引言

这篇博文作为大二数据结构与算法课程自己觉得有意思的算法题的整理记录，不定时更新。

## 一、用List类实现一元多项式的表示与相加

### 1、链表的实现

结构体`Node`作为链表结点，包含指针`next`与两个整型元素：`value`系数和`index`指数。

`List`类包含头指针，头指针指向头结点，头结点默认元素为0。（加上头结点真的可以简化很多操作，insert、delete等操作不需将首尾单独实现）各个结点根据指数由低到高排列。

`List`类的成员函数包括构造函数、析构函数、插入元素、删除元素、查找元素、两个链表的相加。

```cpp

struct Node{
    Node* next;
    int value,index;
    Node(int val=0,int ind=0):value(val),index(ind),next(NULL){}
};

class List{
 public:
    Node* head;
    List() {
        head = new Node();
        head->next=NULL;
    }
    ~List(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
    }
 	void clear(){
    	while(head != NULL){
    		Node *temp=head;
    		head=head->next;
    		delete temp;
    	}
		head = new Node();
     	head->next=NULL;
    }
    void Insert(Node* n);
    void DeleteElement(int k);
    Node* SearchkthNode(int k);
    void MergeList(List &List1, List &List2);
};

```
### 2、具体函数实现

（1）链表元素插入：

比较新加入结点`n`的指数，确定该结点插入的位置，进行插入。

```cpp

void List::Insert(Node* n){
	if(n->value==0)return;
	Node *temp=head; 
	while(temp->next != NULL){ 
		if(temp->next->index >= n->index) break;
		temp=temp->next;
	}
	if(temp->next==NULL || temp->next->index > n->index) {
		Node *p= temp->next;
		temp->next=n;
		n->next=p;
	}
	else {
		temp->next->value += n->value;
		delete n;
	}
	return;
}

```

（2）链表元素删除：

找到第k个结点，将其删除。（第一个元素定义为结点1，以此类推）

```cpp

void List::DeleteElement(int k){
	if(k<=0)return;
	Node *temp=head;
	for(int i=0;i<k-1 && temp != NULL;i++){
		temp=temp->next;
	} 
	if(temp == NULL || temp->next==NULL)return;
	Node *p=temp->next;
	temp->next=p->next;
	delete p;
	return;
}

```

（3）链表元素查找：

查找第k个结点，返回该结点的指针，若该结点不存在，返回`NULL`。

```cpp

Node* List::SearchkthNode(int k){
	if(k<=0)return NULL;
	Node *temp=head;
	for(int i=0;i<k && temp != NULL;i++){
		temp=temp->next;
	}
	return temp;
}

```

（4）两个链表进行相加：

两个链表`list1`、`list2`作为参数传入，进行成员函数操作的链表作为相加的结果。

首先，如果该链表不为空，则先将链表清空，以便插入操作。将`p1``p2`分别指向两个源链表的第一个元素（注意不是头结点），比较两个结点的指数大小，将较小的结点插入新链表尾部；若两个结点指数相等，则将两个结点的系数相加后进行插入。每进行一次插入操作，`p1``p2`向后移一位，直到指向`NULL`。

进行结点操作时注意我们的链表是有头结点的，不需要对头结点进行操作。

```cpp

void List::MergeList(List &list1, List &list2){
	if(head != list1.head && head != list2.head){
		this->clear();
	}
	Node *newhead,*p1=list1.head->next,*p2=list2.head->next;
	newhead = new Node();
	Node *t=newhead;
	while(p1 != NULL && p2 != NULL){
		if(p1->index>p2->index){
 			Node *newone=new Node(p2->value,p2->index);
 			t->next=newone;
 			t=t->next;
 			p2=p2->next;
 		}
 		else if(p1->index<p2->index){
 			Node *newone=new Node(p1->value,p1->index);
 			t->next=newone;
 			t=t->next;
 			p1=p1->next;
 		}
 		else {
 			if(p1->value+p2->value!=0){
				Node *newone=new Node(p1->value+p2->value,p1->index);
	 			t->next=newone;
	 			t=t->next;
 			}
 			p1=p1->next;
 			p2=p2->next;
 		}
	}
	while(p2!=NULL){
		Node *newone=new Node(p2->value,p2->index);
		t->next=newone;
		t=t->next;
		p2=p2->next;
	}
	while(p1!=NULL){
		Node *newone=new Node(p1->value,p1->index);
		t->next=newone;
		t=t->next;
		p1=p1->next;
	}
	head=newhead;
	return;
}

```


### 3、`main`测试函数

main函数利用`srand((int)time(NULL)); `与`rand()%int`生成随机数进行测试，注意包含头文件`#include<windows.h>`、`#include<time.h>`。

```cpp

int main(){
	List list1,list2;
	Node *n1,*n2;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,rand()%20);
		list1.Insert(n1);
	}
	cout<<"list1=";
	Node *t=list1.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	for(int i=0;i<10;i++){
		n1=new Node(rand()%20,i);
		list2.Insert(n1);
	}
	cout<<"list2=";
	t=list2.head->next;
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
	cout<<endl;
	List n;
	n.MergeList(list1,list2);
	t=n.head->next;
	cout<<"n=";
	while(t!=NULL){
		cout<<t->value<<"x^"<<t->index;
		t=t->next;
		if(t!=NULL)cout<<" + ";
	}
} 

```

——2019-09-06

***

## 二、链表排序

给定一个链表和一个值X，操作使得节点值小于X的节点都在大于等于X的节点的前面，并保持每个分区节点的**相对顺序**不变。

* 输入样例
3<br>
6->5->4->3->2->1->5->0

* 输出样例
2->1->0->6->5->4->3->5

### 1、链表结构

```cpp
struct linkNode {
     int val;
     linkNode *next;
     linkNode(){
			val=0;
			next=NULL;
		}
     linkNode(int x) : val(x), next(NULL) {}
     ~linkNode(){}
 };

linkNode* partList(linkNode *head, int x);
```

### 2、排序函数的实现

`linkNode* partList(linkNode *head, int x)`函数用于创造一个完成排序的链表，返回其头指针。

排序中最重要的部分是保持其**相对顺序**不变，实际上可以简单理解成将链表分割成两个子链表，每个子链表中元素的相对顺序与源链表相同，只要在最后将两个子链表连接，就可以得到排序后的链表。

源链表：6->5->4->3->2->1->5->0	（x=3）<br>
子链表一：2->1->0<br>
子链表二：6->5->4->3->5<br>
重新连接：2->1->0->6->5->4->3->5<br>

```cpp
linkNode* partList(linkNode *head, int x){
	linkNode *p=head;
	linkNode *p1=new linkNode(0); //子链表一，为其创建头结点
	
	linkNode *p2=new linkNode(0);//子链表二，为其创建头结点
	
	linkNode *h1=p1,*h2=p2; //需要记录子链表的头结点，且每次都在尾结点插入新元素
	
	while(p!=NULL){ //遍历整个链表
	
		if(p->val < x){
			p1->next=new linkNode(p->val); //若结点数值比x小，给子链表一插入元素
			
			p1=p1->next;
		}
		else {
			p2->next=new linkNode(p->val);//若结点数值大于等于x，给子链表二插入元素
			
			p2=p2->next;
		}
		p=p->next;
	}
	p1->next=h2->next;
	return h1->next; //注意子链表一、子链表二都有头结点，返回时需要跳过
                                        
}
```

### 3、`main`测试函数

```cpp
int main(){
	linkNode *head=NULL;	
	srand((int)time(NULL)); 
	for(int i=0;i<10;i++){
		linkNode *n1=new linkNode(rand()%20);
		n1->next=head;
		head=n1;
	}
	linkNode *head1=partList(head,10);
	while(head!=NULL){
		cout<<head->val<<endl;
		head=head->next;
	}
	cout<<endl;
	while(head1!=NULL){
		cout<<head1->val<<endl;
		head1=head1->next;
	}
} 
```

——2019-09-12

***